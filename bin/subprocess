#!/usr/bin/env node
/*
 * <p>Copyright (c) 2012 by Appcelerator, Inc. All Rights Reserved.
 * Please see the LICENSE file for information about licensing.</p>
 *
 * Provides a "server-like" interface for studio to interact with the code processor
 * @author Bryan Hughes &lt;<a href='mailto:bhughes@appcelerator.com'>bhughes@appcelerator.com</a>&gt;
 */

var path = require('path'),
	fs = require('fs'),
	existsSync = fs.existsSync || path.existsSync,

	wrench = require('wrench'),
	winston = require('winston'),
	appc = require('node-appc'),

	CodeProcessor = require(path.resolve(path.join(__dirname, '..'))),
	Runtime = require(path.resolve(path.join(__dirname, '..', 'lib', 'Runtime'))),

	command = process.argv[2];

switch(command) {
	case 'plugins':
		queryPlugins();
		break;
	case 'options':
		queryOptions();
		break;
	case 'run':
		run();
		break;
	case 'help':
		printHelp();
		break;
	case undefined:
		console.log('Missing command');
		printHelp();
		process.exit(1);
		break;
	default:
		console.log('Unknown command "' + command + '"');
		printHelp();
		process.exit(1);
		break;
}

function printHelp() {
	console.log(
		'\n' +
		'Usage: subprocess run <config file>\n' +
		'       subprocess queryPlugins [<search path> [<search path> [...]]]\n' +
		'       subprocess queryOptions\n\n' +
		'Commands:\n' +
		'   run       Runs the Titanium Code Processor using the supplied config file in interactive mode\n' +
		'   plugins   Queries the plugins in the default search path and the listed search paths\n' +
		'   options   Queries the options\n\n' +
		'Note: this interface is only intended for applications that subprocess the Titanium Code Processor\n');
}

function queryPlugins() {
	CodeProcessor.queryPlugins(function (err, results) {
		if (err) {
			console.error(err);
			process.exit(1);
		} else {
			console.log(JSON.stringify(results));
		}
	});
}

function queryOptions() {
	CodeProcessor.queryOptions(function (err, results) {
		if (err) {
			console.error(err);
			process.exit(1);
		} else {
			console.log(JSON.stringify(results));
		}
	});
}

function run() {

	var config = process.argv[3],
		studioInterface,
		filename,
		logger;

	// Parse the config file
	if (typeof config === 'undefined') {
		console.error('Config file not specified');
		process.exit(1);
	}
	if (!existsSync(config)) {
		console.error('Could not find config file "' + config + '"');
		process.exit(1);
	}
	try {
		config = JSON.parse(fs.readFileSync(config));
	} catch(e) {
		console.error('Could not parse config file: ' + e);
		process.exit(1);
	}

	// Validate the entry point
	if (!config.entryPoint) {
		console.error('Missing entry point in config file');
		process.exit(1);
	}
	if (!existsSync(config.entryPoint)) {
		console.error('Could not find entry point "' + config.entryPoint + '"');
		process.exit(1);
	}

	// Validate the logging and create the logger
	if (config.logging && config.logging.file) {
		filename = config.logging.file.path;
		if (typeof filename === 'undefined') {
			console.error('Path not specified in file logging section');
			process.exit(1);
		}
		if (['trace', 'debug', 'info', 'notice', 'warn', 'error'].indexOf(config.logging.file.level) === -1) {
			console.error('Unknown log level "' + config.logging.file.level + '"');
		}
		if (!existsSync(path.dirname(filename))) {
			wrench.mkdirSyncRecursive(path.dirname(filename));
		}
		logger = new (winston.Logger)({
			transports: [
				new (winston.transports.File)({
					filename: path.resolve(filename),
					level: config.logging.file.level
				})
			],
			levels: {
				trace: 0,
				debug: 1,
				info: 2,
				notice: 3,
				warn: 4,
				error: 5
			}
		});
	}

	// Create the interface
	studioInterface = appc.messaging.create('stdio');
	studioInterface.open();

	studioInterface.listen('exit', function (request, response) {
		studioInterface.close();
		process.exit(1); // TODO: update with something more advanced
	});

	function callback(error) {
		if (error) {
			Runtime.log('error', 'Error communicating with studio: ' + error);
		}
	}

	Runtime.on('enteredFile', function(e) {
		studioInterface.send('enteredFile', e.data.filename, callback);
	});

	Runtime.on('projectProcessingBegin', function() {
		studioInterface.send('projectProcessingBegin', undefined, callback);
	});

	Runtime.on('projectProcessingEnd', function() {
		studioInterface.send('projectProcessingEnd', undefined, callback);
	});

	Runtime.on('warningReported', function(e) {
		var results = {
			type: e.data.name,
			description: e.data.description,
			filename: e.filename,
			line: e.line,
			column: e.column
		};
		studioInterface.send('warningReported', results, callback);
	});

	Runtime.on('errorReported', function(e) {
		var results = {
			type: e.data.name,
			description: e.data.description,
			filename: e.filename,
			line: e.line,
			column: e.column
		};
		studioInterface.send('errorReported', results, callback);
	});

	Runtime.on('consoleOutput', function(e) {
		var results = {
			level: e.data.level,
			message: e.data.message
		};
		studioInterface.send('consoleOutput', results, callback);
	});

	// Run the code processor
	CodeProcessor.process(path.resolve(config.entryPoint), config.options, config.plugins, logger);
	studioInterface.close();
}