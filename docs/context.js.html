<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/base/context.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: lib/base/context.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * &lt;p>Copyright (c) 2009-2013 by Appcelerator, Inc. All Rights Reserved.
 * Please see the LICENSE file for information about licensing.&lt;/p>
 *
 * All classes and helper functions for context
 *
 * @module base/context
 */
/*global
Runtime,
RuleProcessor,
AST,
UnknownType,
UndefinedType,
handleRecoverableNativeException,
type,
ReferenceType,
ObjectType,
FunctionType,
DataPropertyDescriptor,
isAccessorDescriptor,
throwNativeException,
NumberType,
throwTypeError,
toObject
*/

/*****************************************
 *
 * Lexical Environments and Contexts
 *
 *****************************************/

var globalObject,
	contextStack = [],
	functionContextCount = 0,
	tryCatch = 0,
	skippedModeCounter = 0;

// ******** DeclarativeEnvironmentRecord Class ********

function bindingExists (bindings, name) {
	return Object.prototype.hasOwnProperty.call(bindings, name);
}

/**
 * @classdesc ECMA-262 Spec: &lt;em>Declarative environment records are used to define the effect of ECMAScript language
 * syntactic elements such as FunctionDeclarations, VariableDeclarations, and Catch clauses that directly associate
 * identifier bindings with ECMAScript language values. Each declarative environment record is associated with an
 * ECMAScript program scope containing variable and/or function declarations. A declarative environment record binds the
 * set of identifiers defined by the declarations contained within its scope.&lt;/em>
 *
 * @constructor module:base/context.DeclarativeEnvironmentRecord
 * @see ECMA-262 Spec Chapter 10.2.1
 */
exports.DeclarativeEnvironmentRecord = DeclarativeEnvironmentRecord;
function DeclarativeEnvironmentRecord() {
	this._bindings = {};
	this._ambiguousContext = false;
	this._skippedModeStack = [];
}

/**
 * ECMA-262 Spec: &lt;em>The concrete environment record method HasBinding for declarative environment records simply
 * determines if the argument identifier is one of the identifiers bound by the record&lt;/em>
 *
 * @method module:base.DeclarativeEnvironmentRecord#hasBinding
 * @param {string} n The name of the binding
 * @return {boolean} Whether or not this environment record has the binding
 * @see ECMA-262 Spec Chapter 10.2.1.1.1
 */
DeclarativeEnvironmentRecord.prototype.hasBinding = function hasBinding(n) {
	return bindingExists(this._bindings, n);
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method CreateMutableBinding for declarative environment records
 * creates a new mutable binding for the name n that is initialised to the value undefined. A binding must not already
 * exist in this Environment Record for n. If Boolean argument d is provided and has the value true the new binding is
 * marked as being subject to deletion.&lt;/em>
 *
 * @method module:base/context.DeclarativeEnvironmentRecord#createMutableBinding
 * @param {string} n The name of the binding
 * @param {boolean} d Whether or not the binding can be deleted
 * @throws Thrown if the binding already exists
 * @see ECMA-262 Spec Chapter 10.2.1.1.2
 */
DeclarativeEnvironmentRecord.prototype.createMutableBinding = function createMutableBinding(n, d) {
	var bindings = this._bindings;
	if (bindingExists(bindings, n)) {
		throw new Error('Could not create mutable binding: binding "' + n + '" already exists');
	}

	bindings[n] = {
		value: new UndefinedType(),
		alternateValues: {},
		isDeletable: !!d,
		isMutable: true
	};
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method SetMutableBinding for declarative environment records
 * attempts to change the bound value of the current binding of the identifier whose name is the value of the argument
 * N to the value of argument v. A binding for n must already exist. If the binding is an immutable binding, a TypeError
 * is thrown if s is true.&lt;/em>
 *
 * @method module:base/context.DeclarativeEnvironmentRecord#setMutableBinding
 * @param {string} n The name of the binding
 * @param {module:base.BaseType} v The value to set on the binding
 * @param {boolean} s Indicates strict mode, i.e. whether or not an error should be thrown if the binding is not mutable
 * @throws Thrown if the binding does not exist
 * @see ECMA-262 Spec Chapter 10.2.1.1.3
 */
DeclarativeEnvironmentRecord.prototype.setMutableBinding = function setMutableBinding(n, v, s) {
	var bindings = this._bindings;
	if (!bindingExists(bindings, n)) {
		throw new Error('Could not set mutable binding: binding "' + n + '" does not exist');
	}

	if (!bindings[n].isMutable) {
		if (s) {
			handleRecoverableNativeException('TypeError', 'Could not set binding: binding "' + n + '" is not mutable');
			bindings[n].value = new UnknownType();
		} else {
			return;
		}
	}

	if (isLocalSkippedMode() || !this.getBindingValue(n)._isSkippedLocal()) {
		if (type(v) === 'Unknown' || !this.getBindingValue(n)._isLocal() || isAmbiguousBlock()) {
			bindings[n].alternateValues[getSkippedSection()] = new UnknownType();
		} else {
			bindings[n].alternateValues[getSkippedSection()] = v;
		}
	} else {
		if (type(v) === 'Unknown' || !this.getBindingValue(n)._isLocal() || isAmbiguousBlock()) {
			bindings[n].value = new UnknownType();
		} else {
			bindings[n].value = v;
		}
	}
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method GetBindingValue for declarative environment records simply
 * returns the value of its bound identifier whose name is the value of the argument n. The binding must already exist.
 * If s is true and the binding is an uninitialised immutable binding throw a ReferenceError exception.&lt;/em>
 *
 * @method module:base/context.DeclarativeEnvironmentRecord#getBindingValue
 * @param {string} n The name of the binding
 * @param {boolean} s Indicates strict mode, i.e. whether or not an error should be thrown if the binding has not been
 *		initialized
 *	@param {boolean} alternate Whether or not to get the alternate or standard value(s)
 * @return {module:base.BaseType} The value of the binding
 * @throws Thrown if the binding does not exist
 * @see ECMA-262 Spec Chapter 10.2.1.1.4
 */
DeclarativeEnvironmentRecord.prototype.getBindingValue = function getBindingValue(n, s, alternate) {

	var binding = this._bindings[n];
	if (!bindingExists(this._bindings, n)) {
		throw new Error('Could not get value: binding "' + n + '" does not exist');
	}

	if (s &amp;&amp; !binding.isMutable &amp;&amp; !binding.isInitialized) {
		handleRecoverableNativeException('ReferenceError', 'Could not get value: binding "' + n + '" has not been initialized');
		return alternate ? { 1: new UnknownType() } : new UnknownType();
	}

	return alternate ? binding.alternateValues : binding.value;
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method DeleteBinding for declarative environment records can only
 * delete bindings that have been explicitly designated as being subject to deletion.&lt;/em>
 *
 * @method module:base/context.DeclarativeEnvironmentRecord#deleteBinding
 * @param {string} n The name of the binding
 * @return {boolean} Whether or not the binding has been deleted
 * @see ECMA-262 Spec Chapter 10.2.1.1.5
 */
DeclarativeEnvironmentRecord.prototype.deleteBinding = function deleteBinding(n) {

	var binding = this._bindings[n];
	if (!binding) {
		return true;
	}

	if (!binding.isDeletable) {
		return false;
	}

	delete this._bindings[n];
	return true;
};

/**
 * ECMA-262 Spec: &lt;em>Declarative Environment Records always return undefined as their ImplicitThisValue.&lt;/em>
 *
 * @method module:base/context.DeclarativeEnvironmentRecord#implicitThisValue
 * @return {module:base/types/undefined.UndefinedType} Always undefined
 * @see ECMA-262 Spec Chapter 10.2.1.1.6
 */
DeclarativeEnvironmentRecord.prototype.implicitThisValue = function implicitThisValue() {
	return new UndefinedType(); // Always return undefined for declarative environments
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method CreateImmutableBinding for declarative environment records
 * creates a new immutable binding for the name n that is initialised to the value undefined. A binding must not already
 * exist in this environment record for n.&lt;/em>
 *
 * @method module:base/context.DeclarativeEnvironmentRecord#createImmutableBinding
 * @param {string} n The name of the binding
 * @throws Thrown if the binding already exists
 * @see ECMA-262 Spec Chapter 10.2.1.1.7
 */
DeclarativeEnvironmentRecord.prototype.createImmutableBinding = function createImmutableBinding(n) {

	var bindings = this._bindings;
	if (bindingExists(bindings, n)) {
		throw new Error('Could not create immutable binding: binding "' + n + '" already exists');
	}

	bindings[n] = {
		value: new UndefinedType(),
		alternateValues: {},
		isDeletable: false,
		isMutable: false,
		isInitialized: false
	};
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method InitializeImmutableBinding for declarative environment
 * records is used to set the bound value of the current binding of the identifier whose name is the value of the
 * argument n to the value of argument v. An uninitialised immutable binding for n must already exist.&lt;/em>
 *
 * @method module:base/context.DeclarativeEnvironmentRecord#initializeImmutableBinding
 * @param {string} n The name of the binding
 * @param {module:base.BaseType} v The value to initialize the binding to
 * @throws Thrown if the binding does not exist
 * @throws Thrown if the binding is not immutable or has already been initialized
 * @see ECMA-262 Spec Chapter 10.2.1.1.8
 */
DeclarativeEnvironmentRecord.prototype.initializeImmutableBinding = function initializeImmutableBinding(n, v) {

	var binding = this._bindings[n];
	if (!binding) {
		throw new Error('Could not initialize immutable value: binding "' + n + '" does not exist');
	}

	if (binding.isInitialized !== false) {
		throw new Error('Could not initialize immutable value: binding "' + n + '" has either been initialized already or is not an immutable value');
	}

	binding.value = v;
	binding.isInitialized = true;
};

// ******** ObjectEnvironmentRecord Class ********

/**
 * @classdesc ECMA-262 Spec: &lt;em>Object environment records are used to define the effect of ECMAScript elements such as
 * Program and WithStatement that associate identifier bindings with the properties of some object. Each object
 * environment record is associated with an object called its binding object. An object environment record binds
 * the set of identifier names that directly correspond to the property names of its binding object. Property names
 * that are not an IdentifierName are not included in the set of bound identifiers. Both own and inherited properties
 * are included in the set regardless of the setting of their [[enumerable]] attribute. Because properties can be
 * dynamically added and deleted from objects, the set of identifiers bound by an object environment record may
 * potentially change as a side-effect of any operation that adds or deletes properties. Any bindings that are created
 * as a result of such a side-effect are considered to be a mutable binding even if the writable attribute of the
 * corresponding property has the value false. Immutable bindings do not exist for object environment records.&lt;/em>
 *
 * @constructor module:base/context.ObjectEnvironmentRecord
 * @param {module:base.BaseType} bindingObject The object to bind the environment record to
 * @see ECMA-262 Spec Chapter 10.2.1
 */
exports.ObjectEnvironmentRecord = ObjectEnvironmentRecord;
function ObjectEnvironmentRecord(bindingObject) {
	if (!bindingObject) {
		throw '';
	}
	this._bindingObject = bindingObject;
	this._ambiguousContext = false;
	this._skippedModeStack = [];
}

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method HasBinding for object environment records determines if its
 * associated binding object has a property whose name is the value of the argument n&lt;/em>
 *
 * @method module:base/context.ObjectEnvironmentRecord#hasBinding
 * @param {string} n The name of the binding
 * @return {boolean} Whether or not this environment record has the binding
 * @see ECMA-262 Spec Chapter 10.2.1.2.1
 */
ObjectEnvironmentRecord.prototype.hasBinding = function hasBinding(n) {
	return this._bindingObject.hasProperty(n);
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method CreateMutableBinding for object environment records creates
 * in an environment record‘s associated binding object a property whose name is the String value and initialises it to
 * the value undefined. A property named n must not already exist in the binding object. If Boolean argument d is
 * provided and has the value true the new property‘s [[configurable]] attribute is set to true, otherwise it is set to
 * false.&lt;/em>
 *
 * @method module:base/context.ObjectEnvironmentRecord#createMutableBinding
 * @param {string} n The name of the binding
 * @param {boolean} d Whether or not the binding can be deleted
 * @param {boolean} suppressEvent Suppresses the 'propertySet' event (used when setting prototypes)
 * @throws Thrown if the binding already exists
 * @see ECMA-262 Spec Chapter 10.2.1.2.2
 */
ObjectEnvironmentRecord.prototype.createMutableBinding = function createMutableBinding(n, d, suppressEvent) {
	var bindingObject = this._bindingObject;
	if (bindingObject.hasProperty(n)) {
		throw new Error('Internal Error: could not create mutable binding: binding "' + n + '" already exists');
	}

	bindingObject.defineOwnProperty(n, {
		value: new UndefinedType(),
		writable: true,
		enumerable: true,
		configurable: !!d
	}, true, suppressEvent);
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method SetMutableBinding for object environment records attempts
 * to set the value of the environment record‘s associated binding object‘s property whose name is the value of the
 * argument n to the value of argument V. A property named N should already exist but if it does not or is not currently
 * writable, error handling is determined by the value of the Boolean argument s.&lt;/em>
 *
 * @method module:base/context.ObjectEnvironmentRecord#setMutableBinding
 * @param {string} n The name of the binding
 * @param {module:base.BaseType} v The value to set on the binding
 * @param {boolean} s Indicates strict mode, i.e. whether or not an error should be thrown if the binding is not mutable
 * @param {boolean} suppressEvent Suppresses the 'propertySet' event (used when setting prototypes)
 * @see ECMA-262 Spec Chapter 10.2.1.2.3
 */
ObjectEnvironmentRecord.prototype.setMutableBinding = function setMutableBinding(n, v, s, suppressEvent) {
	this._bindingObject.put(n, v, s, suppressEvent);
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method SetMutableBinding for object environment records attempts
 * to set the value of the environment record‘s associated binding object‘s property whose name is the value of the
 * argument n to the value of argument v. A property named N should already exist but if it does not or is not currently
 * writable, error handling is determined by the value of the Boolean argument s.&lt;/em>
 *
 * @method module:base/context.ObjectEnvironmentRecord#getBindingValue
 * @param {string} n The name of the binding
 * @param {boolean} s Indicates strict mode, i.e. whether or not an error should be thrown if the binding has not been
 *		initialized
 * @param {boolean} alternate Whether or not to get the alternate or standard value(s)
 * @return {module:base.BaseType} The value of the binding
 * @see ECMA-262 Spec Chapter 10.2.1.2.4
 */
ObjectEnvironmentRecord.prototype.getBindingValue = function getBindingValue(n, s, alternate) {
	var bindingObject = this._bindingObject;
	if (!bindingObject.hasProperty(n)) {
		if (s) {
			handleRecoverableNativeException('ReferenceError', 'Property ' + n + ' does not exist');
			return new UnknownType();
		}
		return new UndefinedType();
	}

	return bindingObject.get(n, alternate);
};

/**
 * ECMA-262 Spec: &lt;em>The concrete Environment Record method DeleteBinding for object environment records can only
 * delete bindings that correspond to properties of the environment object whose [[configurable]] attribute have the
 * value true.&lt;/em>
 *
 * @method module:base/context.ObjectEnvironmentRecord#deleteBinding
 * @param {string} n The name of the binding
 * @return {boolean} Whether or not the binding has been deleted
 * @see ECMA-262 Spec Chapter 10.2.1.2.5
 */
ObjectEnvironmentRecord.prototype.deleteBinding = function deleteBinding(n) {
	return this._bindingObject['delete'](n, false);
};

/**
 * ECMA-262 Spec: &lt;em>Object Environment Records return undefined as their ImplicitThisValue unless their provideThis
 * flag is true.&lt;/em>
 *
 * @method module:base/context.ObjectEnvironmentRecord#implicitThisValue
 * @return {module:base.BaseType} The value of this, if it exists
 * @see ECMA-262 Spec Chapter 10.2.1.2.6
 */
ObjectEnvironmentRecord.prototype.implicitThisValue = function implicitThisValue() {
	if (this.provideThis) {
		return this._bindingObject;
	} else {
		return new UndefinedType();
	}
};

// ******** Lexical Environment ********

/**
 * @classdesc ECMA-262 Spec: &lt;em>A Lexical Environment is a specification type used to define the association of
 * Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A
 * Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment.
 * Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a
 * FunctionDeclaration, a WithStatement, or a Catch clause of a TryStatement and a new Lexical Environment is created
 * each time such code is evaluated.&lt;/em>
 *
 * @constructor module:base/context~LexicalEnvironment
 * @param {(module:base/context.DeclarativeEnvironmentRecord | module:base/context.ObjectEnvironmentRecord)} envRec The environment record
 *		to associate with the new lexical environment
 * @param {module:base/context~LexicalEnvironment} [outer] The outer lexical environment
 * @property {module:base/context.DeclarativeEnvironmentRecord|module:base/context.ObjectEnvironmentRecord} envRec The environment
 *		record associated with this lexical environment
 * @property {(module:base/context~LexicalEnvironment | undefined)} outer The outer lexical environment of this lexical environment,
 *		if it exists
 * @see ECMA-262 Spec Chapter 10.2
 */
function LexicalEnvironment(envRec, outer) {
	this.envRec = envRec;
	this.outer = outer;
}

// ******** Lexical Environment Operations ********

/**
 * ECMA-262 Spec: &lt;em>The abstract operation GetIdentifierReference is called with a Lexical Environment lex, an
 * identifier String name, and a Boolean flag strict. The value of lex may be null.&lt;/em>
 *
 * @method module:base/context.getIdentifierReference
 * @param {(module:base/context~LexicalEnvironment | undefined)} lex The lexical environment to search
 * @param {string} name The name of the identifier
 * @param {boolean} strict Whether or not to fetch the identifier in strict mode
 * @see ECMA-262 Spec Chapter 10.2.2.1
 */
exports.getIdentifierReference = getIdentifierReference;
function getIdentifierReference(lex, name, strict) {
	var newRef;
	if (!lex) {
		newRef = new ReferenceType();
		newRef.baseValue = new UndefinedType();
		newRef.referencedName = name;
		newRef.strictReference = strict;
		return newRef;
	}
	if (lex.envRec.hasBinding(name)) {
		newRef = new ReferenceType();
		newRef.baseValue = lex.envRec;
		newRef.referencedName = name;
		newRef.strictReference = strict;
		return newRef;
	} else {
		return getIdentifierReference(lex.outer, name, strict);
	}
}

/**
 * Creates a new lexical environment with a declarative environment record
 *
 * @method module:base/context.newDeclarativeEnvironment
 * @param {(module:base/context~LexicalEnvironment | undefined)} e The outer lexical environment of the new lexical environment
 * @return {module:base/context~LexicalEnvironment} The newly created lexical environment
 * @see ECMA-262 Spec Chapter 10.2.2.2
 */
exports.newDeclarativeEnvironment = newDeclarativeEnvironment;
function newDeclarativeEnvironment(e) {
	return new LexicalEnvironment(new DeclarativeEnvironmentRecord(), e);
}

/**
 * Creates a new lexical environment with an object environment record
 *
 * @method module:base/context.newObjectEnvironment
 * @param {module:base/types/object.ObjectType} o The binding object
 * @param {(module:base/context~LexicalEnvironment | undefined)} e The outer lexical environment of the new lexical environment
 * @return {module:base/context~LexicalEnvironment} The newly created lexical environment
 * @see ECMA-262 Spec Chapter 10.2.2.3
 */
exports.newObjectEnvironment = newObjectEnvironment;
function newObjectEnvironment(o, e) {
	return new LexicalEnvironment(new ObjectEnvironmentRecord(o), e);
}

// ******** Execution Context ********

/**
 * @classdesc ECMA-262 Spec: &lt;em>When control is transferred to ECMAScript executable code, control is entering an
 * execution context. Active execution contexts logically form a stack. The top execution context on this logical stack
 * is the running execution context. A new execution context is created whenever control is transferred from the
 * executable code associated with the currently running execution context to executable code that is not associated
 * with that execution context. The newly created execution context is pushed onto the stack and becomes the running
 * execution context. An execution context contains whatever state is necessary to track the execution progress of its
 * associated code.&lt;/em>
 *
 * @constructor module:base/context~ExecutionContext
 * @param {module:base/context~LexicalEnvironment} lexicalEnvironment ECMA-262 Spec: &lt;em>Identifies the Lexical Environment
 *		used to resolve identifier references made by code within this execution context.&lt;/em>
 * @param {module:base/context~LexicalEnvironment} variableEnvironment ECMA-262 Spec: &lt;em>Identifies the Lexical Environment
 *		whose environment record holds bindings created by VariableStatements and FunctionDeclarations within this
 *		execution context.&lt;/em>
 * @param {module:base/types/object.ObjectType} thisBinding ECMA-262 Spec: &lt;em>The value associated with the this keyword within
 *		ECMAScript code associated with this execution context.&lt;/em>
 * @param {boolean} strict Indicates whether or not this execution context is strict mode
 * @property {module:base/context~LexicalEnvironment} lexicalEnvironment ECMA-262 Spec: &lt;em>Identifies the Lexical Environment
 *		used to resolve identifier references made by code within this execution context.&lt;/em>
 * @property {module:base/context~LexicalEnvironment} variableEnvironment ECMA-262 Spec: &lt;em>Identifies the Lexical Environment
 *		whose environment record holds bindings created by VariableStatements and FunctionDeclarations within this
 *		execution context.&lt;/em>
 * @property {module:base/types/object.ObjectType} thisBinding ECMA-262 Spec: &lt;em>The value associated with the this keyword within
 *		ECMAScript code associated with this execution context.&lt;/em>
 * @property {boolean} strict Indicates whether or not this execution context is strict mode
 */
function ExecutionContext(lexicalEnvironment, variableEnvironment, thisBinding, strict) {
	this.lexicalEnvironment = lexicalEnvironment;
	this.variableEnvironment = variableEnvironment;
	this.thisBinding = thisBinding;
	this.strict = typeof strict != 'undefined' ? strict : false;
	this._ambiguousBlock = 0;
}

// ******** Context Creation Methods ********

/**
 * @private
 */
function findDeclarations(ast, context) {
	var functions = [],
		variables = [];

	AST.walk(ast, [
		{
			nodeType: 'AST_Defun',
			callback: function(node) {
				var formalParameterList = [],
					i, len;
				for (i = 0, len = node.argnames.length; i &lt; len; i++) {
					formalParameterList.push(node.argnames[i].name);
				}
				node._lastKnownContext = context;
				functions.push(node);
				Runtime.addFunction(node);
				return true;
			}
		},
		{
			nodeType: 'AST_Var',
			callback: function(node) {
				var i, len;
				for (i = 0, len = node.definitions.length; i &lt; len; i++) {
					variables.push({
						variableName: node.definitions[i].name.name
					});
					if (node.definitions[i].value &amp;&amp; node.definitions[i].value.className === 'AST_Function') {
						node.definitions[i].value._lastKnownContext = context;
						Runtime.addFunction(node.definitions[i].value);
					}
				}
				return true;
			}
		},
		{
			nodeType: 'AST_Const',
			callback: function(node) {
				var i, len;
				for (i = 0, len = node.definitions.length; i &lt; len; i++) {
					variables.push({
						variableName: node.definitions[i].name.name
					});
				}
				return true;
			}
		},
		{
			nodeType: 'AST_Function',
			callback: function(node) {
				node._lastKnownContext = context;
				Runtime.addFunction(node);
				return true;
			}
		}
	]);

	return {
		functions: functions,
		variables: variables
	};
}

/**
 * @private
 */
function processFunctionDefinition(node) {

	var identifier = node.name.name,
		formalParameterList = [],
		context = getCurrentContext(),
		strict = context.strict || RuleProcessor.isBlockStrict(node),
		functionObject,
		i,
		len;

	RuleProcessor.fireRuleEvent(node, {}, false);
	RuleProcessor.logRule('AST_Defun', identifier);

	setVisited(node.name);

	for (i = 0, len = node.argnames.length; i &lt; len; i++) {
		setVisited(node.argnames[i]);
		formalParameterList.push(node.argnames[i].name);
	}

	try {
		if (strict) {
			if (identifier === 'eval' || identifier === 'arguments') {
				handleRecoverableNativeException('SyntaxError', identifier + ' is not a valid identifier name');
				throw 'Unknown';
			}
			for (i = 0, len = formalParameterList.length; i &lt; len; i++) {
				if (formalParameterList[i] === 'eval' || formalParameterList[i] === 'arguments') {
					handleRecoverableNativeException('SyntaxError', formalParameterList[i] + ' is not a valid identifier name');
					throw 'Unknown';
				}
				if (formalParameterList.indexOf(formalParameterList[i], i + 1) !== -1) {
					handleRecoverableNativeException('SyntaxError', 'Duplicate parameter names are not allowed in strict mode');
					throw 'Unknown';
				}
			}
		}

		functionObject = new FunctionType(formalParameterList, node, context.lexicalEnvironment, strict);
		functionObject._location = {
			filename: node.start.file,
			line: node.start.line,
			column: node.start.column
		};
		functionObject._ast = node;
	} catch(e) {
		if (e === 'Unknown') {
			functionObject = new UnknownType();
		} else {
			throw e;
		}
	}

	RuleProcessor.fireRuleEvent(node, {
		identifier: identifier,
		formalParameterList: formalParameterList,
		strict: strict,
		functionObject: functionObject
	}, true);

	return functionObject;
}

/**
 * Creates the global context
 *
 * @method module:base/context.createGlobalContext
 * @param {boolean} strict Indicates whether or not this execution context is strict mode
 * @return {module:base/context~ExecutionContext} The new global execution context
 * @see ECMA-262 Spec Chapter 10.4.1 and Chapter 10.5
 */
exports.createGlobalContext = createGlobalContext;
function createGlobalContext(strict) {

	// Create the context
	globalObject = new ObjectType();
	var env = newObjectEnvironment(globalObject),
		executionContext = new ExecutionContext(
			env,
			env,
			globalObject,
			strict);
	globalObject._closure = globalObject;
	enterContext(executionContext);

	// Return the context
	return executionContext;
}

/**
 * Initializes the global context with its AST. This must happen AFTER Base.init() is called
 *
 * @method module:base/context.initGlobalAST
 * @param {module:AST.node} ast The AST associated with this global context
 */
exports.initGlobalAST = initGlobalAST;
function initGlobalAST(ast) {
	var globalContext = getGlobalContext(),
		result = findDeclarations(ast, globalContext),
		functions = result.functions,
		variables = result.variables,
		env = globalContext.variableEnvironment.envRec,
		strict = RuleProcessor.isBlockStrict(ast),
		i, len,
		fn,
		fo,
		funcAlreadyDeclared,
		configurableBindings = false,
		existingProp,
		descriptor,
		dn,
		varAlreadyDeclared;

	// Find all of the function declarations and bind them
	for (i = 0, len = functions.length; i &lt; len; i++) {
		fn = functions[i].name.name;
		fo = functions[i]._funcObject = processFunctionDefinition(functions[i]);
		funcAlreadyDeclared = env.hasBinding(fn);

		if (!funcAlreadyDeclared) {
			env.createMutableBinding(fn, configurableBindings);
		} else if (env === getGlobalContext().variableEnvironment.envRec) {
			existingProp = globalObject.getProperty(fn);
			if (existingProp.configurable) {
				descriptor = new DataPropertyDescriptor();
				descriptor.writable = true;
				descriptor.enumerable = true;
				descriptor.configurable = configurableBindings;
				globalObject.defineOwnProperty(fn, descriptor, true);
			} else if (isAccessorDescriptor(existingProp) || (existingProp.writable !== true &amp;&amp;
					existingProp.enumerable !== true)) {
				throwNativeException('TypeError', fn +
					' is not a valid identifier name because a non-writable identifier with that name already exists');
			}
		}

		env.setMutableBinding(fn, fo, strict);
	}

	// Find all of the variable declarations and bind them
	for (i = 0, len = variables.length; i &lt; len; i++) {
		dn = variables[i].variableName,
		varAlreadyDeclared = env.hasBinding(dn);

		if (!varAlreadyDeclared) {
			env.createMutableBinding(dn, configurableBindings);
			env.setMutableBinding(dn, new UndefinedType(), strict);
		}
	}
}

/**
 * Creates a module context
 *
 * @method module:base/context.createGlobalContext
 * @param {module:AST.node} ast The AST associated with this global context
 * @param {boolean} strict Indicates whether or not this execution context is strict mode
 * @param {boolean} createExports Whether or not to create a module.exports object in this context
 * @param {boolean} ambiguous Whether or not this is an ambiguous context
 * @return {module:base/context~ExecutionContext} The new global execution context
 * @see ECMA-262 Spec Chapter 10.4.1 and Chapter 10.5
 */
exports.createModuleContext = createModuleContext;
function createModuleContext(ast, strict, createExports, ambiguous) {

	// Create the context
	var moduleObject = new ObjectType(),
		env = newObjectEnvironment(moduleObject, getGlobalContext().variableEnvironment),
		configurableBindings = false,
		executionContext = new ExecutionContext(
			env,
			env,
			moduleObject,
			strict),
		len, i,
		functions, variables, result,
		fn, fo,
		funcAlreadyDeclared,
		existingProp,
		descriptor,
		dn,
		varAlreadyDeclared,
		exportsObject;
	env.envRec._ambiguousContext = !!ambiguous;
	enterContext(executionContext);
	env = executionContext.variableEnvironment.envRec;

	result = findDeclarations(ast, executionContext);
	functions = result.functions;
	variables = result.variables;

	if (createExports) {
		exportsObject = new ObjectType(),
		moduleObject.put('exports', exportsObject, false);
		env.createMutableBinding('module', true);
		env.setMutableBinding('module', moduleObject);
	}

	// Find all of the function declarations and bind them
	for (i = 0, len = functions.length; i &lt; len; i++) {
		fn = functions[i].name.name;
		fo = functions[i]._funcObject = processFunctionDefinition(functions[i]);
		funcAlreadyDeclared = env.hasBinding(fn);

		if (!funcAlreadyDeclared) {
			env.createMutableBinding(fn, configurableBindings);
		} else if (env === getGlobalContext().variableEnvironment.envRec) {
			existingProp = moduleObject.getProperty(fn);
			if (existingProp.configurable) {
				descriptor = new DataPropertyDescriptor();
				descriptor.writable = true;
				descriptor.enumerable = true;
				descriptor.configurable = configurableBindings;
				moduleObject.defineOwnProperty(fn, descriptor, true);
			} else if (isAccessorDescriptor(existingProp) || (existingProp.writable !== true &amp;&amp;
					existingProp.enumerable !== true)) {
				throwNativeException('TypeError', fn +
					' is not a valid identifier name because a non-writable identifier with that name already exists');
			}
		}

		env.setMutableBinding(fn, fo, strict);
	}

	// Find all of the variable declarations and bind them
	for (i = 0, len = variables.length; i &lt; len; i++) {
		dn = variables[i].variableName,
		varAlreadyDeclared = env.hasBinding(dn);

		if (!varAlreadyDeclared) {
			env.createMutableBinding(dn, configurableBindings);
			env.setMutableBinding(dn, new UndefinedType(), strict);
		}
	}

	// Return the context
	return executionContext;
}

/**
 * Creates an eval context
 *
 * @method module:base/context.createEvalContext
 * @param {(module:base/context~ExecutionContext | undefined)} callingContext The context that is evaling code
 * @param {module:AST.node} code The code associated with this eval context
 * @param {boolean} strict Whether or not this context is a strict mode context
 * @return {module:base/context~ExecutionContext} The new eval execution context
 * @see ECMA-262 Spec Chapter 10.4.2 and Chapter 10.5
 */
exports.createEvalContext = createEvalContext;
function createEvalContext(callingContext, code, strict, isDirectEval) {

	var executionContext,
		env,
		configurableBindings = true,
		len, i,
		result,
		functions,
		variables,
		fn,
		fo,
		funcAlreadyDeclared,
		existingProp,
		descriptor,
		dn,
		varAlreadyDeclared;

	// Create or set the execution context
	if (!callingContext || !isDirectEval) {
		callingContext = getModuleContext();
	}
	executionContext = new ExecutionContext(
		callingContext.lexicalEnvironment,
		callingContext.variableEnvironment,
		callingContext.thisBinding,
		callingContext.strict || strict
	);
	enterContext(executionContext);

	// Create the inner lexical environment if this is strict mode code
	if (executionContext.strict) {
		executionContext.variableEnvironment = executionContext.lexicalEnvironment =
			newDeclarativeEnvironment(executionContext.lexicalEnvironment);
	}

	// Bind the function and variable declarations to the global context
	env = executionContext.variableEnvironment.envRec;
	result = findDeclarations(code, executionContext);
	functions = result.functions;
	variables = result.variables;

	// Find all of the function declarations and bind them
	for (i = 0, len = functions.length; i &lt; len; i++) {
		fn = functions[i].name.name;
		fo = functions[i]._funcObject = processFunctionDefinition(functions[i]);
		funcAlreadyDeclared = env.hasBinding(fn);

		if (!funcAlreadyDeclared) {
			env.createMutableBinding(fn, configurableBindings);
		} else if (env === getGlobalContext().variableEnvironment.envRec) {
			existingProp = getGlobalObject().getProperty(fn);
			if (existingProp.configurable) {
				descriptor = new DataPropertyDescriptor();
				descriptor.writable = true;
				descriptor.enumerable = true;
				descriptor.configurable = configurableBindings;
				getGlobalObject().defineOwnProperty(fn, descriptor, true);
			} else if (isAccessorDescriptor(existingProp) || (existingProp.writable !== true &amp;&amp;
					existingProp.enumerable !== true)) {
				throwNativeException('TypeError', fn +
					' is not a valid identifier name because a non-writable identifier with that name already exists');
			}
		}

		env.setMutableBinding(fn, fo, executionContext.strict);
	}

	// Find all of the variable declarations and bind them
	for (i = 0, len = variables.length; i &lt; len; i++) {
		dn = variables[i].variableName;
		varAlreadyDeclared = env.hasBinding(dn);

		if (!varAlreadyDeclared) {
			env.createMutableBinding(dn, configurableBindings);
			env.setMutableBinding(dn, new UndefinedType(), executionContext.strict);
		}
	}

	return executionContext;
}

/**
 * Gets the global object
 *
 * @method module:Runtime.getGlobalObject
 * @return {module:base/types/object.ObjectType} The global object
 */
exports.getGlobalObject = getGlobalObject;
function getGlobalObject() {
	return globalObject;
}

/**
 * Enters an ambiguous block in the current context
 *
 * @method module:base/context.enterAmbiguousBlock
 */
exports.enterAmbiguousBlock = enterAmbiguousBlock;
function enterAmbiguousBlock() {
	getCurrentContext()._ambiguousBlock++;
}

/**
 * Exits an ambiguous block in the current context
 *
 * @method module:base/context.exitAmbiguousBlock
 */
exports.exitAmbiguousBlock = exitAmbiguousBlock;
function exitAmbiguousBlock() {
	getCurrentContext()._ambiguousBlock--;
}

/**
 * Checks if the current block in the current context is ambiguous
 *
 * @method module:base/context.isAmbiguousBlock
 */
exports.isAmbiguousBlock = isAmbiguousBlock;
function isAmbiguousBlock() {
	return !!getCurrentContext()._ambiguousBlock;
}

/**
 * Processes code in skipped mode
 *
 * @method module:base/context.processInSkippedMode
 * @param {Function} [...] The operations to run in skipped mode
 */
exports.processInSkippedMode = processInSkippedMode;
function processInSkippedMode() {
	var i, len,
		result;

	// Short-circuit skipped mode in blacklisted files
	if (Runtime.isCurrentFileBlacklisted()) {
		return;
	}

	// Enter skipped mode
	getCurrentContext().lexicalEnvironment.envRec._skippedModeStack.push(++skippedModeCounter);

	// Analyze the code
	try {
		for (i = 0, len = arguments.length; i &lt; len; i++) {
			result = arguments[i]();
		}
	} catch(e) {
		if (RuleProcessor.inRecursionUnroll() || !e.isCodeProcessorException) {
			throw e;
		}
	}
	finally {
		// Exit skippd mode
		getCurrentContext().lexicalEnvironment.envRec._skippedModeStack.pop();
	}
	return result;
}

/**
 * Checks if we are skipped mode
 *
 * @method module:base/context.isSkippedMode
 * @return {boolean} Whether or not we are in skipped mode
 */
exports.isSkippedMode = isSkippedMode;
function isSkippedMode() {
	var stack = getContextStack(),
		i, len;
	for (i = 0, len = stack.length; i &lt; len; i++) {
		if (stack[i].lexicalEnvironment.envRec._skippedModeStack.length) {
			return true;
		}
	}
	return false;
}

/**
 * Checks if the current context is in skipped mode
 *
 * @method module:base/context.isLocalSkippedMode
 * @return {boolean} Whether or not we are in skipped mode
 */
exports.isLocalSkippedMode = isLocalSkippedMode;
function isLocalSkippedMode() {
	return !!getCurrentContext().lexicalEnvironment.envRec._skippedModeStack.length;
}

/**
 * Gets the section of code that we are currently in. This is used to scope alternate values only to the appropriate
 * section of code in a context (typically a block, but not always).
 *
 * @method module:base/context.getSkippedSection
 * @return {number} The section id, which should be treated as an opaque id
 */
exports.getSkippedSection = getSkippedSection;
function getSkippedSection() {
	var contextStack = getContextStack(),
		skippedStack,
		i;
	for (i = contextStack.length - 1; i >= 0; i--) {
		skippedStack = contextStack[i].lexicalEnvironment.envRec._skippedModeStack;
		if (skippedStack.length) {
			return skippedStack[skippedStack.length - 1];
		}
	}
}

/**
 * Sets the given node as visited, taking the other states into account
 *
 * @method module:base/context.setVisited
 * @param {module:AST.node} ast The ast to set as visited
 */
exports.setVisited = setVisited;
function setVisited(ast) {
	if (isSkippedMode()) {
		ast._skipped = !ast._visited;
	} else {
		ast._visited = true;
		ast._skipped = false;
	}
}

/**
 * Enters the current try catch block
 *
 * @method module:base/context.enterTryCatch
 */
exports.enterTryCatch = enterTryCatch;
function enterTryCatch() {
	tryCatch++;
}

/**
 * Exits the current try catch block
 *
 * @method module:base/context.exitTryCatch
 */
exports.exitTryCatch = exitTryCatch;
function exitTryCatch() {
	tryCatch--;
}

/**
 * Checks if we are currently in a try-catch block
 *
 * @method module:base/context.inTryCatch
 */
exports.inTryCatch = inTryCatch;
function inTryCatch() {
	return !!tryCatch;
}

/**
 * Gets the current execution context
 *
 * @method module:base/context.getCurrentContext
 * @return {module:base/context~ExecutionContext} The current execution context
 */
exports.getCurrentContext = getCurrentContext;
function getCurrentContext() {
	return contextStack[contextStack.length - 1];
}

/**
 * Get the context stack
 *
 * @method module:base/context.getContextStack
 * @return {Array.&lt;module:base/context~ExecutionContext>} The execution context stack
 */
exports.getContextStack = getContextStack;
function getContextStack() {
	return contextStack;
}

/**
 * Enters the given file, from a runtime perspective, i.e. if file a requires file b and calls foo in b from a, then the
 * current file becomes b, even though a is the current file being processed
 *
 * @method module:base/context.enterContext
 * @param {string} file The name of the file to enter
 */
exports.enterContext = enterContext;
function enterContext(context) {
	Runtime.log('trace', 'Entering new context');
	contextStack.push(context);
	if (context.isFunctionContext) {
		functionContextCount++;
	}
}

/**
 * Exits the current file, from a runtime perspective
 *
 * @method module:base/context.exitContext
 */
exports.exitContext = exitContext;
function exitContext() {
	Runtime.log('trace', 'Exiting context');
	var context = contextStack.pop();
	if (context.isFunctionContext) {
		functionContextCount--;
	}
	return context;
}

/**
 * Returns whether or not we are in a function context (i.e. not in global scope)
 *
 * @method module:base/context.inFunctionContext
 * @return {boolean} Whether or not we are in a function context
 */
exports.inFunctionContext = inFunctionContext;
function inFunctionContext() {
	return !!functionContextCount;
}

/**
 * Gets the global execution context
 *
 * @method module:base/context.getGlobalContext
 * @return {module:base/context~ExecutionContext} The global execution context
 */
exports.getGlobalContext = getGlobalContext;
function getGlobalContext() {
	return contextStack[0];
}

/**
 * Gets the module object of the current module context (i.e. the 'global' object associated with this module)
 *
 * @method module:base/context.getModuleContext
 * @return {module:base/types/object.ObjectType} The module object
 */
exports.getModuleContext = getModuleContext;
function getModuleContext() {
	return contextStack[1] || contextStack[0];
}

/**
 * ECMA-262 Spec: &lt;em>When control enters an execution context for function code, an arguments object is created unless
 * (as specified in 10.5) the identifier arguments occurs as an Identifier in the function‘s FormalParameterList or
 * occurs as the Identifier of a VariableDeclaration or FunctionDeclaration contained in the function code.&lt;/em>
 *
 * @method module:base/context.createArgumentsObject
 * @param {module:base/types/function.FunctionType} func ECMA-262 Spec: &lt;em>the function object whose code is to be evaluated&lt;/em>
 * @param {Array.&lt;string>} names ECMA-262 Spec: &lt;em>a List containing the function‘s formal parameter names&lt;/em>
 * @param {Array.&lt;module:base.BaseType>} args ECMA-262 Spec: &lt;em>the actual arguments passed to the [[call]] internal method&lt;/em>
 * @param {module:base/context~LexicalEnvironment} env ECMA-262 Spec: &lt;em>the variable environment for the function code&lt;/em>
 * @param {boolean} strict ECMA-262 Spec: &lt;em>a Boolean that indicates whether or not the function code is strict code&lt;/em>
 * @return {module:base/types/object.ObjectType} The arguments object
 * @see ECMA-262 Spec Chapter 10.4.2 and Chapter 10.6
 */
function createArgumentsObject(func, names, args, env, strict) {
	var len = args.length,
		obj = new ObjectType(),
		map = new ObjectType(),
		mappedNames = [],
		indx = len - 1,
		val,
		name;

	obj.className = 'Arguments';
	obj.defineOwnProperty('length', {
		value: new NumberType(len),
		writable: true,
		enumerable: false,
		configurable: true
	}, false, true);

	while (indx >= 0) {
		val = args[indx];
		obj.defineOwnProperty(indx, {
			value: val,
			writable: true,
			enumerable: true,
			configurable: true
		}, false, true);
		if (indx &lt; names.length) {
			name = names[indx];
			if (!strict &amp;&amp; !bindingExists(mappedNames, name)) {
				mappedNames.push(name);
				map.defineOwnProperty(indx, {
					// Note: we have to do this crazy parse since returns aren't allowedin global scope
					get: new FunctionType([], AST.parseString('function temp () { return ' + name + '; }').body[0], env, true),
					set: new FunctionType([name + '_arg'], AST.parseString(name + ' = ' + name + '_arg;'), env, true),
					configurable: true
				}, false, true);
			}
		}
		indx--;
	}

	if (mappedNames.length) {
		obj.parameterMap = map;

		obj.get = function get(p, alternate) {
			var isMapped = map.getOwnProperty(p, alternate),
				v;
			if (isMapped) {
				return map.get(p, alternate);
			} else {
				v = ObjectType.prototype.get.call(obj, p, alternate);
				if (p === 'callee' &amp;&amp; v.className === 'Function' &amp;&amp; v.strict) {
					throwNativeException('TypeError', 'Invalid identifier ' + p);
				}
				return v;
			}
		};

		obj.getOwnProperty = function getOwnProperty(p, alternate) {
			var desc = ObjectType.prototype.getOwnProperty.call(obj, p, alternate),
				alternateDesc,
				i, len,
				isMapped;

			if (!desc) {
				return;
			}

			isMapped = map.getOwnProperty(p, alternate);
			if (isMapped) {
				if (alternate) {
					alternateDesc = map.get(p, alternate);
					for (i = 0, len = desc.length; i &lt; len; i++) {
						desc[i].value = alternateDesc[i];
					}
				} else {
					desc.value = map.get(p, alternate);
				}
			}
			return desc;
		};

		obj.defineOwnProperty = function defineOwnProperty(p, desc, throwFlag, suppressEvent) {
			var isMapped = map.getOwnProperty(p),
				allowed = ObjectType.prototype.defineOwnProperty.call(obj, p, desc, throwFlag, suppressEvent);

			if (!allowed) {
				if (throwFlag) {
					throwNativeException('TypeError', 'Cannot define property ' + p);
				}
				return false;
			}

			if (isMapped) {
				if (isAccessorDescriptor(desc)) {
					map['delete'](p, false);
				} else {
					if (desc.value) {
						map.put(p, desc.value, throwFlag, true);
					}
					if (desc.writable === false) {
						map['delete'](p, false);
					}
				}
			}
		};

		obj['delete'] = function (p, throwFlag) {
			var isMapped = map.getOwnProperty(p),
				result = ObjectType.prototype['delete'].call(obj, p, throwFlag);
			if (result &amp;&amp; isMapped) {
				map['delete'](p, false);
			}
			return result;
		};
	}

	if (strict) {
		obj.defineOwnProperty('caller', {
			get: throwTypeError,
			set: throwTypeError,
			enumerable: false,
			configurable: false
		}, false, true);
		obj.defineOwnProperty('callee', {
			get: throwTypeError,
			set: throwTypeError,
			enumerable: false,
			configurable: false
		}, false, true);
	} else {
		obj.defineOwnProperty('callee', {
			value: func,
			writable: true,
			enumerable: false,
			configurable: true
		}, false, true);
	}

	return obj;
}

/**
 * Creates a function context
 *
 * @method module:base/context.createFunctionContext
 * @param {module:base/types/object.ObjectType} functionObject The function object of the context to be created.
 * @param {module:base/types/object.ObjectType} thisArg The object to bind the this pointer to
 * @param {Array.&lt;module:base.BaseType>} argumentsList The list of function arguments
 * @return {module:base/context~ExecutionContext} The new global execution context
 * @see ECMA-262 Spec Chapter 10.4.3 and Chapter 10.5
 */
exports.createFunctionContext = createFunctionContext;
function createFunctionContext(functionObject, thisArg, argumentsList, scope) {

	// Create the context
	var env = newDeclarativeEnvironment(scope || functionObject.scope),
		configurableBindings = false,
		strict = functionObject.strict,
		executionContext,
		len, i,
		arg, argName,
		functions, variables, result,
		thisArgType = type(thisArg),
		thisBinding,
		fn,
		fo,
		funcAlreadyDeclared,
		existingProp,
		descriptor,
		argsObj,
		dn,
		varAlreadyDeclared;

	// Create the this binding
	if (functionObject.strict) {
		thisBinding = thisArg;
	} else if (thisArgType === 'Null' || thisArgType === 'Undefined') {
		thisBinding = getGlobalContext().thisBinding;
	} else if (thisArgType !== 'Object') {
		thisBinding = toObject(thisArg);
	} else {
		thisBinding = thisArg;
	}

	// Create the execution context and find declarations inside of it
	executionContext = new ExecutionContext(env, env, thisBinding, strict);
	executionContext.isFunctionContext = true;
	enterContext(executionContext);
	env = executionContext.variableEnvironment.envRec;
	result = findDeclarations(AST.createBodyContainer(functionObject.code), executionContext);
	functions = result.functions;
	variables = result.variables;

	// Initialize the arguments
	for (i = 0, len = functionObject.formalParameters.length; i &lt; len; i++) {
		arg = argumentsList[i];
		argName = functionObject.formalParameters[i];
		if (!arg) {
			arg = new UndefinedType();
		}
		if (!env.hasBinding(argName)) {
			env.createMutableBinding(argName);
		}
		env.setMutableBinding(argName, arg, strict);
	}

	// Find all of the function declarations and bind them
	for (i = 0, len = functions.length; i &lt; len; i++) {
		fn = functions[i].name.name;
		fo = functions[i]._funcObject = processFunctionDefinition(functions[i]);
		funcAlreadyDeclared = env.hasBinding(fn);

		if (!funcAlreadyDeclared) {
			env.createMutableBinding(fn, configurableBindings);
		} else if (env === getGlobalContext().variableEnvironment.envRec) {
			existingProp = getGlobalObject().getProperty(fn);
			if (existingProp.configurable) {
				descriptor = new DataPropertyDescriptor();
				descriptor.writable = true;
				descriptor.enumerable = true;
				descriptor.configurable = configurableBindings;
				getGlobalObject().defineOwnProperty(fn, descriptor, true);
			} else if (isAccessorDescriptor(existingProp) || (existingProp.writable !== true &amp;&amp;
					existingProp.enumerable !== true)) {
				throwNativeException('TypeError', fn +
					' is not a valid identifier name because a non-writable identifier with that name already exists');
			}
		}

		env.setMutableBinding(fn, fo, strict);
	}

	// Initialize the arguments variable
	if (!env.hasBinding('arguments')) {
		argsObj = createArgumentsObject(functionObject, functionObject.formalParameters, argumentsList, executionContext.variableEnvironment, strict);
		if (strict) {
			env.createImmutableBinding('arguments');
			env.initializeImmutableBinding('arguments', argsObj);
		} else {
			env.createMutableBinding('arguments');
			env.setMutableBinding('arguments', argsObj, false);
		}
	}

	// Find all of the variable declarations and bind them
	for (i = 0, len = variables.length; i &lt; len; i++) {
		dn = variables[i].variableName;
		varAlreadyDeclared = env.hasBinding(dn);

		if (!varAlreadyDeclared) {
			env.createMutableBinding(dn, configurableBindings);
			env.setMutableBinding(dn, new UndefinedType(), strict);
		}
	}

	// Return the context
	return executionContext;
}

/**
 * Wraps a native call method and provides necessary context setup and cleanup
 *
 * @method module:base/context.wrapNativeCall
 * @param {Function} func The function to wrap
 * @param {boolean} isConstructor Whether or not this is a constructure (constructors are handled differently)
 * @return {Function} The newly wrapped function
 */
exports.wrapNativeCall = wrapNativeCall;
function wrapNativeCall (func, isConstructor) {

	return function (thisVal) {

		// Create the context
		var env = newDeclarativeEnvironment(getCurrentContext().lexicalEnvironment),
			executionContext = new ExecutionContext(env, env, isConstructor ? getModuleContext().thisBinding : thisVal, false),
			result;

		executionContext.isFunctionContext = true;
		enterContext(executionContext);

		try {
			result = func.apply(this, arguments);
		} finally {
			exitContext();
		}

		return result;
	};
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-AST.html">AST</a></li><li><a href="module-base.html">base</a></li><li><a href="array.html">base/constructors/array</a></li><li><a href="boolean.html">base/constructors/boolean</a></li><li><a href="date.html">base/constructors/date</a></li><li><a href="error.html">base/constructors/error</a></li><li><a href="function.html">base/constructors/function</a></li><li><a href="number.html">base/constructors/number</a></li><li><a href="object.html">base/constructors/object</a></li><li><a href="regexp.html">base/constructors/regexp</a></li><li><a href="string.html">base/constructors/string</a></li><li><a href="context.html">base/context</a></li><li><a href="conversion.html">base/conversion</a></li><li><a href="exceptions.html">base/exceptions</a></li><li><a href="init.html">base/init</a></li><li><a href="array_.html">base/prototypes/array</a></li><li><a href="boolean_.html">base/prototypes/boolean</a></li><li><a href="date_.html">base/prototypes/date</a></li><li><a href="error_.html">base/prototypes/error</a></li><li><a href="function_.html">base/prototypes/function</a></li><li><a href="number_.html">base/prototypes/number</a></li><li><a href="object_.html">base/prototypes/object</a></li><li><a href="regexp_.html">base/prototypes/regexp</a></li><li><a href="string_.html">base/prototypes/string</a></li><li><a href="array__.html">base/types/array</a></li><li><a href="boolean__.html">base/types/boolean</a></li><li><a href="function__.html">base/types/function</a></li><li><a href="null.html">base/types/null</a></li><li><a href="number__.html">base/types/number</a></li><li><a href="object__.html">base/types/object</a></li><li><a href="reference.html">base/types/reference</a></li><li><a href="regexp__.html">base/types/regexp</a></li><li><a href="string__.html">base/types/string</a></li><li><a href="undefined.html">base/types/undefined</a></li><li><a href="unknown.html">base/types/unknown</a></li><li><a href="module-CodeProcessor.html">CodeProcessor</a></li><li><a href="module-CodeProcessorUtils.html">CodeProcessorUtils</a></li><li><a href="TiApiDeprecationFinder.html">plugins/TiApiDeprecationFinder</a></li><li><a href="TiApiIncludeFinder.html">plugins/TiApiIncludeFinder</a></li><li><a href="TiApiPlatformValidator.html">plugins/TiApiPlatformValidator</a></li><li><a href="TiApiProvider.html">plugins/TiApiProvider</a></li><li><a href="globals.html">plugins/TiApiProvider/globals</a></li><li><a href="require.html">plugins/TiApiProvider/require</a></li><li><a href="Ti.html">plugins/TiApiProvider/Ti</a></li><li><a href="API.html">plugins/TiApiProvider/Ti/API</a></li><li><a href="App.html">plugins/TiApiProvider/Ti/App</a></li><li><a href="Properties.html">plugins/TiApiProvider/Ti/App/Properties</a></li><li><a href="FileSystem.html">plugins/TiApiProvider/Ti/FileSystem</a></li><li><a href="Window.html">plugins/TiApiProvider/Ti/UI/Window</a></li><li><a href="TiApiRequireFinder.html">plugins/TiApiRequireFinder</a></li><li><a href="TiApiUsageFinder.html">plugins/TiApiUsageFinder</a></li><li><a href="module-RuleProcessor.html">RuleProcessor</a></li><li><a href="AST_Accessor.html">rules/AST_Accessor</a></li><li><a href="AST_Array.html">rules/AST_Array</a></li><li><a href="AST_Assign.html">rules/AST_Assign</a></li><li><a href="AST_Binary.html">rules/AST_Binary</a></li><li><a href="AST_BlockStatement.html">rules/AST_BlockStatement</a></li><li><a href="AST_Break.html">rules/AST_Break</a></li><li><a href="AST_Call.html">rules/AST_Call</a></li><li><a href="AST_Conditional.html">rules/AST_Conditional</a></li><li><a href="AST_Const.html">rules/AST_Const</a></li><li><a href="AST_Continue.html">rules/AST_Continue</a></li><li><a href="AST_Debugger.html">rules/AST_Debugger</a></li><li><a href="AST_Defun.html">rules/AST_Defun</a></li><li><a href="AST_Directive.html">rules/AST_Directive</a></li><li><a href="AST_Do.html">rules/AST_Do</a></li><li><a href="AST_Dot.html">rules/AST_Dot</a></li><li><a href="AST_EmptyStatement.html">rules/AST_EmptyStatement</a></li><li><a href="AST_False.html">rules/AST_False</a></li><li><a href="AST_For.html">rules/AST_For</a></li><li><a href="AST_ForIn.html">rules/AST_ForIn</a></li><li><a href="AST_Function.html">rules/AST_Function</a></li><li><a href="AST_Hole.html">rules/AST_Hole</a></li><li><a href="AST_If.html">rules/AST_If</a></li><li><a href="AST_Infinity.html">rules/AST_Infinity</a></li><li><a href="AST_LabeledStatement.html">rules/AST_LabeledStatement</a></li><li><a href="AST_NaN.html">rules/AST_NaN</a></li><li><a href="AST_New.html">rules/AST_New</a></li><li><a href="AST_Null.html">rules/AST_Null</a></li><li><a href="AST_Number.html">rules/AST_Number</a></li><li><a href="AST_Object.html">rules/AST_Object</a></li><li><a href="AST_RegExp.html">rules/AST_RegExp</a></li><li><a href="AST_Return.html">rules/AST_Return</a></li><li><a href="AST_Seq.html">rules/AST_Seq</a></li><li><a href="AST_SimpleStatement.html">rules/AST_SimpleStatement</a></li><li><a href="AST_String.html">rules/AST_String</a></li><li><a href="AST_Sub.html">rules/AST_Sub</a></li><li><a href="AST_Switch.html">rules/AST_Switch</a></li><li><a href="AST_SymbolRef.html">rules/AST_SymbolRef</a></li><li><a href="AST_This.html">rules/AST_This</a></li><li><a href="AST_Throw.html">rules/AST_Throw</a></li><li><a href="AST_Toplevel.html">rules/AST_Toplevel</a></li><li><a href="AST_True.html">rules/AST_True</a></li><li><a href="AST_Try.html">rules/AST_Try</a></li><li><a href="AST_UnaryPostfix.html">rules/AST_UnaryPostfix</a></li><li><a href="AST_UnaryPrefix.html">rules/AST_UnaryPrefix</a></li><li><a href="AST_Undefined.html">rules/AST_Undefined</a></li><li><a href="AST_Var.html">rules/AST_Var</a></li><li><a href="AST_While.html">rules/AST_While</a></li><li><a href="AST_With.html">rules/AST_With</a></li><li><a href="module-Runtime.html">Runtime</a></li></ul><h3>Classes</h3><ul><li><a href="module-base.BaseType.html">BaseType</a></li><li><a href="context.DeclarativeEnvironmentRecord.html">DeclarativeEnvironmentRecord</a></li><li><a href="context.ObjectEnvironmentRecord.html">ObjectEnvironmentRecord</a></li><li><a href="context-ExecutionContext.html">ExecutionContext</a></li><li><a href="context-LexicalEnvironment.html">LexicalEnvironment</a></li><li><a href="array.ArrayPrototypeType.html">ArrayPrototypeType</a></li><li><a href="boolean.BooleanPrototypeType.html">BooleanPrototypeType</a></li><li><a href="date.DatePrototypeType.html">DatePrototypeType</a></li><li><a href="error.ErrorPrototypeType.html">ErrorPrototypeType</a></li><li><a href="function.FunctionPrototypeType.html">FunctionPrototypeType</a></li><li><a href="number.NumberPrototypeType.html">NumberPrototypeType</a></li><li><a href="object.ObjectPrototypeType.html">ObjectPrototypeType</a></li><li><a href="regexp.RegExpPrototypeType.html">RegExpPrototypeType</a></li><li><a href="string.StringPrototypeType.html">StringPrototypeType</a></li><li><a href="array.ArrayType.html">ArrayType</a></li><li><a href="boolean.BooleanType.html">BooleanType</a></li><li><a href="function.FunctionType.html">FunctionType</a></li><li><a href="function.FunctionTypeBase.html">FunctionTypeBase</a></li><li><a href="null.NullType.html">NullType</a></li><li><a href="number.NumberType.html">NumberType</a></li><li><a href="object.AccessorPropertyDescriptor.html">AccessorPropertyDescriptor</a></li><li><a href="object.DataPropertyDescriptor.html">DataPropertyDescriptor</a></li><li><a href="object.ObjectType.html">ObjectType</a></li><li><a href="reference.ReferenceType.html">ReferenceType</a></li><li><a href="regexp.RegExpType.html">RegExpType</a></li><li><a href="string.StringType.html">StringType</a></li><li><a href="undefined.UndefinedType.html">UndefinedType</a></li><li><a href="unknown.UnknownType.html">UnknownType</a></li><li><a href="module-Runtime.Evented.html">Evented</a></li></ul><h3>Events</h3><ul><li><a href="array.ArrayType.html#event:propertyDefined">propertyDefined</a></li><li><a href="array.ArrayType.html#event:propertyDeleted">propertyDeleted</a></li><li><a href="array.ArrayType.html#event:propertyReferenced">propertyReferenced</a></li><li><a href="array.ArrayType.html#event:propertySet">propertySet</a></li><li><a href="object.ObjectType.html#event:propertyDefined">propertyDefined</a></li><li><a href="object.ObjectType.html#event:propertyDeleted">propertyDeleted</a></li><li><a href="object.ObjectType.html#event:propertyReferenced">propertyReferenced</a></li><li><a href="object.ObjectType.html#event:propertySet">propertySet</a></li><li><a href="module-CodeProcessor.html#event:enteredFile">enteredFile</a></li><li><a href="module-CodeProcessor.html#event:errorReported">errorReported</a></li><li><a href="module-CodeProcessor.html#event:maxIterationsExceeded">maxIterationsExceeded</a></li><li><a href="module-CodeProcessor.html#event:maxRecusionLimitReached">maxRecusionLimitReached</a></li><li><a href="module-CodeProcessor.html#event:projectProcessingBegin">projectProcessingBegin</a></li><li><a href="module-CodeProcessor.html#event:projectProcessingEnd">projectProcessingEnd</a></li><li><a href="module-CodeProcessor.html#event:undeclaredGlobalVariableCreated">undeclaredGlobalVariableCreated</a></li><li><a href="module-CodeProcessor.html#event:warningReported">warningReported</a></li><li><a href="TiApiProvider.html#event:tiPropertyDeleted">tiPropertyDeleted</a></li><li><a href="TiApiProvider.html#event:tiPropertyReferenced">tiPropertyReferenced</a></li><li><a href="TiApiProvider.html#event:tiPropertySet">tiPropertySet</a></li><li><a href="TiApiProvider-TiObjectType.html#event:propertyDefined">propertyDefined</a></li><li><a href="TiApiProvider-TiObjectType.html#event:propertyDeleted">propertyDeleted</a></li><li><a href="TiApiProvider-TiObjectType.html#event:propertyReferenced">propertyReferenced</a></li><li><a href="TiApiProvider-TiObjectType.html#event:propertySet">propertySet</a></li><li><a href="AST_Accessor.html#event:rule">rule</a></li><li><a href="AST_Array.html#event:rule">rule</a></li><li><a href="AST_Assign.html#event:rule">rule</a></li><li><a href="AST_Binary.html#event:rule">rule</a></li><li><a href="AST_BlockStatement.html#event:rule">rule</a></li><li><a href="AST_Break.html#event:rule">rule</a></li><li><a href="AST_Call.html#event:rule">rule</a></li><li><a href="AST_Conditional.html#event:rule">rule</a></li><li><a href="AST_Const.html#event:rule">rule</a></li><li><a href="AST_Continue.html#event:rule">rule</a></li><li><a href="AST_Debugger.html#event:rule">rule</a></li><li><a href="AST_Defun.html#event:rule">rule</a></li><li><a href="AST_Directive.html#event:rule">rule</a></li><li><a href="AST_Do.html#event:rule">rule</a></li><li><a href="AST_Dot.html#event:rule">rule</a></li><li><a href="AST_EmptyStatement.html#event:rule">rule</a></li><li><a href="AST_False.html#event:rule">rule</a></li><li><a href="AST_For.html#event:rule">rule</a></li><li><a href="AST_ForIn.html#event:rule">rule</a></li><li><a href="AST_Function.html#event:rule">rule</a></li><li><a href="AST_Hole.html#event:rule">rule</a></li><li><a href="AST_If.html#event:rule">rule</a></li><li><a href="AST_Infinity.html#event:rule">rule</a></li><li><a href="AST_LabeledStatement.html#event:rule">rule</a></li><li><a href="AST_NaN.html#event:rule">rule</a></li><li><a href="AST_New.html#event:rule">rule</a></li><li><a href="AST_Null.html#event:rule">rule</a></li><li><a href="AST_Number.html#event:rule">rule</a></li><li><a href="AST_Object.html#event:rule">rule</a></li><li><a href="AST_RegExp.html#event:rule">rule</a></li><li><a href="AST_Return.html#event:rule">rule</a></li><li><a href="AST_Seq.html#event:rule">rule</a></li><li><a href="AST_SimpleStatement.html#event:rule">rule</a></li><li><a href="AST_String.html#event:rule">rule</a></li><li><a href="AST_Sub.html#event:rule">rule</a></li><li><a href="AST_Switch.html#event:rule">rule</a></li><li><a href="AST_SymbolRef.html#event:rule">rule</a></li><li><a href="AST_This.html#event:rule">rule</a></li><li><a href="AST_Throw.html#event:rule">rule</a></li><li><a href="AST_Toplevel.html#event:rule">rule</a></li><li><a href="AST_True.html#event:rule">rule</a></li><li><a href="AST_Try.html#event:rule">rule</a></li><li><a href="AST_UnaryPostfix.html#event:rule">rule</a></li><li><a href="AST_UnaryPrefix.html#event:rule">rule</a></li><li><a href="AST_Undefined.html#event:rule">rule</a></li><li><a href="AST_Var.html#event:rule">rule</a></li><li><a href="AST_While.html#event:rule">rule</a></li><li><a href="AST_With.html#event:rule">rule</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha2</a> on Thu Nov 14 2013 15:31:12 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
